{
  "language": "Solidity",
  "sources": {
    "contracts/PrisionersDilemma.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract PrisonersDilemma {\n\tuint256 public entryFee = 1 gwei;\n\tuint256 public roundDuration = 1 minutes; // DuraciÃ³n de cada ronda\n\taddress public owner;\n\n\tstruct Player {\n\t\tuint256 balance;\n\t\tuint256 score;\n\t\tbool inGame;\n\t\tbool decision; // true = cooperate, false = defect\n\t\tbool decided;\n\t\tuint256 currentRoom;\n\t}\n\n\tstruct Room {\n\t\taddress player1;\n\t\taddress player2;\n\t\tbool active;\n\t\tuint256 roundEnd;\n\t}\n\n\tmapping(address => Player) public players;\n\tRoom[] public rooms;\n\n\tevent GameStarted(\n\t\taddress indexed player1,\n\t\taddress indexed player2,\n\t\tuint256 roomId\n\t);\n\tevent DecisionMade(address indexed player, uint256 roomId, bool decision);\n\tevent RewardsDistributed(uint256 roomId, address player1, address player2);\n\tevent PlayerJoined(address indexed player, uint256 roomId);\n\tevent RoomCreated(uint256 roomId, address player);\n\tevent RoundReset(uint256 roomId);\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner, \"Not the contract owner\");\n\t\t_;\n\t}\n\n\tmodifier onlyPlayer() {\n\t\trequire(players[msg.sender].inGame, \"Not a registered player\");\n\t\t_;\n\t}\n\n\tconstructor() {\n\t\towner = msg.sender;\n\t}\n\n\tfunction joinGame() public payable {\n\t\trequire(msg.value == entryFee, \"Must send exactly 1 gwei\");\n\t\trequire(!players[msg.sender].inGame, \"Already in game\");\n\n\t\tplayers[msg.sender] = Player({\n\t\t\tbalance: msg.value,\n\t\t\tscore: msg.value,\n\t\t\tinGame: true,\n\t\t\tdecision: false,\n\t\t\tdecided: false,\n\t\t\tcurrentRoom: 0\n\t\t});\n\n\t\tmatchPlayer();\n\t}\n\n\tfunction matchPlayer() internal {\n\t\tfor (uint256 i = 0; i < rooms.length; i++) {\n\t\t\tif (\n\t\t\t\trooms[i].active &&\n\t\t\t\t(rooms[i].player1 == address(0) ||\n\t\t\t\t\trooms[i].player2 == address(0))\n\t\t\t) {\n\t\t\t\tif (rooms[i].player1 == address(0)) {\n\t\t\t\t\trooms[i].player1 = msg.sender;\n\t\t\t\t} else {\n\t\t\t\t\trooms[i].player2 = msg.sender;\n\t\t\t\t\trooms[i].roundEnd = block.timestamp + roundDuration;\n\t\t\t\t\temit GameStarted(rooms[i].player1, rooms[i].player2, i);\n\t\t\t\t}\n\t\t\t\tplayers[msg.sender].currentRoom = i;\n\t\t\t\tplayers[msg.sender].inGame = true; // Update inGame status\n\t\t\t\temit PlayerJoined(msg.sender, i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\trooms.push(\n\t\t\tRoom({\n\t\t\t\tplayer1: msg.sender,\n\t\t\t\tplayer2: address(0),\n\t\t\t\tactive: true,\n\t\t\t\troundEnd: block.timestamp + roundDuration // Set the round end time for new room\n\t\t\t})\n\t\t);\n\t\tuint256 newRoomId = rooms.length - 1;\n\t\tplayers[msg.sender].currentRoom = newRoomId;\n\t\tplayers[msg.sender].inGame = true; // Update inGame status\n\t\temit RoomCreated(newRoomId, msg.sender);\n\t}\n\n\tfunction makeDecision(bool decision) public onlyPlayer {\n\t\tuint256 roomId = players[msg.sender].currentRoom;\n\t\trequire(roomId < rooms.length, \"Invalid room\");\n\t\tRoom storage room = rooms[roomId];\n\t\trequire(room.active, \"Room is not active\");\n\t\trequire(block.timestamp <= room.roundEnd, \"Round has ended\");\n\n\t\tif (msg.sender == room.player1) {\n\t\t\tplayers[msg.sender].decision = decision;\n\t\t\tplayers[msg.sender].decided = true;\n\t\t} else if (msg.sender == room.player2) {\n\t\t\tplayers[msg.sender].decision = decision;\n\t\t\tplayers[msg.sender].decided = true;\n\t\t}\n\n\t\temit DecisionMade(msg.sender, roomId, decision);\n\n\t\tif (players[room.player1].decided && players[room.player2].decided) {\n\t\t\tdistributeRewards(roomId);\n\t\t}\n\t}\n\n\tfunction distributeRewards(uint256 roomId) internal {\n\t\tRoom storage room = rooms[roomId];\n\t\tPlayer storage player1 = players[room.player1];\n\t\tPlayer storage player2 = players[room.player2];\n\n\t\tif (block.timestamp > room.roundEnd) {\n\t\t\t// Round has ended without decisions from both players, refund entry fees\n\t\t\tif (!player1.decided) {\n\t\t\t\tplayer1.inGame = false;\n\t\t\t\t(bool success1, ) = room.player1.call{ value: player1.balance }(\n\t\t\t\t\t\"\"\n\t\t\t\t);\n\t\t\t\trequire(success1, \"Refund to player1 failed\");\n\t\t\t\tplayer1.balance = 0;\n\t\t\t\tplayer1.score = 0;\n\t\t\t}\n\t\t\tif (!player2.decided) {\n\t\t\t\tplayer2.inGame = false;\n\t\t\t\t(bool success2, ) = room.player2.call{ value: player2.balance }(\n\t\t\t\t\t\"\"\n\t\t\t\t);\n\t\t\t\trequire(success2, \"Refund to player2 failed\");\n\t\t\t\tplayer2.balance = 0;\n\t\t\t\tplayer2.score = 0;\n\t\t\t}\n\t\t\troom.active = false;\n\t\t\temit RoundReset(roomId);\n\t\t\treturn;\n\t\t}\n\n\t\tif (player1.decision && player2.decision) {\n\t\t\t// Both cooperate\n\t\t\tplayer1.balance = player1.balance;\n\t\t\tplayer2.balance = player2.balance;\n\t\t} else if (!player1.decision && player2.decision) {\n\t\t\t// Player 1 defects, Player 2 cooperates\n\t\t\tuint256 amount = player2.balance / 2;\n\t\t\tplayer2.balance = amount;\n\t\t\tplayer1.balance = player1.balance + amount;\n\t\t} else if (player1.decision && !player2.decision) {\n\t\t\t// Player 1 cooperates, Player 2 defects\n\t\t\tuint256 amount = player1.balance / 2;\n\t\t\tplayer1.balance = amount;\n\t\t\tplayer2.balance = player2.balance + amount;\n\t\t} else {\n\t\t\t// Both defect\n\t\t\tplayer1.balance = player1.balance / 2;\n\t\t\tplayer2.balance = player2.balance / 2;\n\t\t}\n\n\t\tplayer1.score = player1.balance;\n\t\tplayer2.score = player2.balance;\n\n\t\tplayer1.decided = false;\n\t\tplayer2.decided = false;\n\n\t\temit RewardsDistributed(roomId, room.player1, room.player2);\n\n\t\t// Reset room for next round\n\t\troom.roundEnd = block.timestamp + roundDuration;\n\t}\n\n\tfunction withdraw() public onlyPlayer {\n\t\tuint256 balance = players[msg.sender].balance;\n\t\trequire(balance > 0, \"No balance to withdraw\");\n\n\t\t// Remove the player from the current room\n\t\tuint256 currentRoom = players[msg.sender].currentRoom;\n\t\tif (rooms[currentRoom].player1 == msg.sender) {\n\t\t\trooms[currentRoom].player1 = address(0);\n\t\t} else if (rooms[currentRoom].player2 == msg.sender) {\n\t\t\trooms[currentRoom].player2 = address(0);\n\t\t}\n\n\t\tdelete players[msg.sender];\n\n\t\t(bool success, ) = msg.sender.call{ value: balance }(\"\");\n\t\trequire(success, \"Withdrawal failed\");\n\t}\n\n\tfunction getRanking()\n\t\tpublic\n\t\tview\n\t\treturns (address[] memory, uint256[] memory)\n\t{\n\t\tuint256 playerCount = 0;\n\t\tfor (uint256 i = 0; i < rooms.length; i++) {\n\t\t\tif (rooms[i].player1 != address(0)) playerCount++;\n\t\t\tif (rooms[i].player2 != address(0)) playerCount++;\n\t\t}\n\n\t\taddress[] memory addresses = new address[](playerCount);\n\t\tuint256[] memory scores = new uint256[](playerCount);\n\t\tuint256 index = 0;\n\t\taddress[] memory addedAddresses = new address[](playerCount);\n\n\t\tfor (uint256 i = 0; i < rooms.length; i++) {\n\t\t\tif (rooms[i].player1 != address(0)) {\n\t\t\t\tbool alreadyAdded = false;\n\t\t\t\tfor (uint256 j = 0; j < index; j++) {\n\t\t\t\t\tif (addedAddresses[j] == rooms[i].player1) {\n\t\t\t\t\t\talreadyAdded = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!alreadyAdded) {\n\t\t\t\t\taddresses[index] = rooms[i].player1;\n\t\t\t\t\tscores[index] = players[rooms[i].player1].score;\n\t\t\t\t\taddedAddresses[index] = rooms[i].player1;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rooms[i].player2 != address(0)) {\n\t\t\t\tbool alreadyAdded = false;\n\t\t\t\tfor (uint256 j = 0; j < index; j++) {\n\t\t\t\t\tif (addedAddresses[j] == rooms[i].player2) {\n\t\t\t\t\t\talreadyAdded = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!alreadyAdded) {\n\t\t\t\t\taddresses[index] = rooms[i].player2;\n\t\t\t\t\tscores[index] = players[rooms[i].player2].score;\n\t\t\t\t\taddedAddresses[index] = rooms[i].player2;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (addresses, scores);\n\t}\n\n\tfunction getPlayersByRooms()\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\taddress[] memory,\n\t\t\tuint256[] memory,\n\t\t\tuint256[] memory,\n\t\t\tbool[] memory\n\t\t)\n\t{\n\t\tuint256 playerCount = 0;\n\t\tfor (uint256 i = 0; i < rooms.length; i++) {\n\t\t\tif (rooms[i].player1 != address(0)) playerCount++;\n\t\t\tif (rooms[i].player2 != address(0)) playerCount++;\n\t\t}\n\n\t\taddress[] memory addresses = new address[](playerCount);\n\t\tuint256[] memory balances = new uint256[](playerCount);\n\t\tuint256[] memory roomsIds = new uint256[](playerCount);\n\t\tbool[] memory inGames = new bool[](playerCount);\n\n\t\tuint256 index = 0;\n\t\tfor (uint256 i = 0; i < rooms.length; i++) {\n\t\t\tif (rooms[i].player1 != address(0)) {\n\t\t\t\taddresses[index] = rooms[i].player1;\n\t\t\t\tbalances[index] = players[rooms[i].player1].balance;\n\t\t\t\troomsIds[index] = i;\n\t\t\t\tinGames[index] = players[rooms[i].player1].inGame;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tif (rooms[i].player2 != address(0)) {\n\t\t\t\taddresses[index] = rooms[i].player2;\n\t\t\t\tbalances[index] = players[rooms[i].player2].balance;\n\t\t\t\troomsIds[index] = i;\n\t\t\t\tinGames[index] = players[rooms[i].player2].inGame;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\n\t\treturn (addresses, balances, roomsIds, inGames);\n\t}\n\n\tfunction getPlayers()\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\taddress[] memory,\n\t\t\tuint256[] memory,\n\t\t\tuint256[] memory,\n\t\t\tbool[] memory,\n\t\t\tbool[] memory,\n\t\t\tbool[] memory,\n\t\t\tuint256[] memory\n\t\t)\n\t{\n\t\tuint256 playerCount = 0;\n\t\tfor (uint256 i = 0; i < rooms.length; i++) {\n\t\t\tif (rooms[i].player1 != address(0)) playerCount++;\n\t\t\tif (rooms[i].player2 != address(0)) playerCount++;\n\t\t}\n\n\t\taddress[] memory addresses = new address[](playerCount);\n\t\tuint256[] memory balances = new uint256[](playerCount);\n\t\tuint256[] memory scores = new uint256[](playerCount);\n\t\tbool[] memory inGames = new bool[](playerCount);\n\t\tbool[] memory decisions = new bool[](playerCount);\n\t\tbool[] memory decideds = new bool[](playerCount);\n\t\tuint256[] memory currentRooms = new uint256[](playerCount);\n\n\t\tuint256 index = 0;\n\t\tfor (uint256 i = 0; i < rooms.length; i++) {\n\t\t\tif (rooms[i].player1 != address(0)) {\n\t\t\t\taddresses[index] = rooms[i].player1;\n\t\t\t\tbalances[index] = players[rooms[i].player1].balance;\n\t\t\t\tscores[index] = players[rooms[i].player1].score;\n\t\t\t\tinGames[index] = players[rooms[i].player1].inGame;\n\t\t\t\tdecisions[index] = players[rooms[i].player1].decision;\n\t\t\t\tdecideds[index] = players[rooms[i].player1].decided;\n\t\t\t\tcurrentRooms[index] = players[rooms[i].player1].currentRoom;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tif (rooms[i].player2 != address(0)) {\n\t\t\t\taddresses[index] = rooms[i].player2;\n\t\t\t\tbalances[index] = players[rooms[i].player2].balance;\n\t\t\t\tscores[index] = players[rooms[i].player2].score;\n\t\t\t\tinGames[index] = players[rooms[i].player2].inGame;\n\t\t\t\tdecisions[index] = players[rooms[i].player2].decision;\n\t\t\t\tdecideds[index] = players[rooms[i].player2].decided;\n\t\t\t\tcurrentRooms[index] = players[rooms[i].player2].currentRoom;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\n\t\treturn (\n\t\t\taddresses,\n\t\t\tbalances,\n\t\t\tscores,\n\t\t\tinGames,\n\t\t\tdecisions,\n\t\t\tdecideds,\n\t\t\tcurrentRooms\n\t\t);\n\t}\n\n\tfunction getContractBalance() public view returns (uint256) {\n\t\treturn address(this).balance;\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}